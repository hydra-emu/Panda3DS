diff --git a/src/host_shaders/opengl_display.frag b/src/host_shaders/opengl_display.frag
index 612671c8..1937f711 100644
--- a/src/host_shaders/opengl_display.frag
+++ b/src/host_shaders/opengl_display.frag
@@ -1,4 +1,5 @@
-#version 410 core
+#version 300 es
+precision mediump float;
 in vec2 UV;
 out vec4 FragColor;
 
diff --git a/src/host_shaders/opengl_display.vert b/src/host_shaders/opengl_display.vert
index 990e2f80..6917c23c 100644
--- a/src/host_shaders/opengl_display.vert
+++ b/src/host_shaders/opengl_display.vert
@@ -1,4 +1,4 @@
-#version 410 core
+#version 300 es
 out vec2 UV;
 
 void main() {
diff --git a/src/host_shaders/opengl_fragment_shader.frag b/src/host_shaders/opengl_fragment_shader.frag
index f6fa6c55..b0850438 100644
--- a/src/host_shaders/opengl_fragment_shader.frag
+++ b/src/host_shaders/opengl_fragment_shader.frag
@@ -1,4 +1,5 @@
-#version 410 core
+#version 300 es
+precision mediump float;
 
 in vec3 v_tangent;
 in vec3 v_normal;
@@ -27,7 +28,7 @@ uniform bool u_depthmapEnable;
 uniform sampler2D u_tex0;
 uniform sampler2D u_tex1;
 uniform sampler2D u_tex2;
-uniform sampler1DArray u_tex_lighting_lut;
+// uniform sampler1DArray u_tex_lighting_lut;
 
 uniform uint u_picaRegs[0x200 - 0x48];
 
@@ -145,9 +146,15 @@ vec4 tevCalculateCombiner(int tev_id) {
 #define RR_LUT 6u
 
 float lutLookup(uint lut, uint light, float value) {
-	if (lut >= FR_LUT && lut <= RR_LUT) lut -= 1;
-	if (lut == SP_LUT) lut = light + 8;
-	return texture(u_tex_lighting_lut, vec2(value, lut)).r;
+	// if (lut >= FR_LUT && lut <= RR_LUT) lut -= 1;
+	// if (lut == SP_LUT) lut = light + 8;
+	// return texture(u_tex_lighting_lut, vec2(value, lut)).r;
+	return 0.0;
+}
+
+uint bitfieldExtract(uint val, int off, int size) {
+    uint mask = uint((1 << size) - 1);
+    return uint(val >> off) & mask;
 }
 
 vec3 regToColor(uint reg) {
diff --git a/src/host_shaders/opengl_vertex_shader.vert b/src/host_shaders/opengl_vertex_shader.vert
index a25d7a6d..5967ccd6 100644
--- a/src/host_shaders/opengl_vertex_shader.vert
+++ b/src/host_shaders/opengl_vertex_shader.vert
@@ -1,4 +1,4 @@
-#version 410 core
+#version 300 es
 
 layout(location = 0) in vec4 a_coords;
 layout(location = 1) in vec4 a_quaternion;
@@ -20,7 +20,7 @@ out vec2 v_texcoord2;
 flat out vec4 v_textureEnvColor[6];
 flat out vec4 v_textureEnvBufferColor;
 
-out float gl_ClipDistance[2];
+// out float gl_ClipDistance[2];
 
 // TEV uniforms
 uniform uint u_textureEnvColor[6];
@@ -93,6 +93,6 @@ void main() {
 	);
 
 	// There's also another, always-on clipping plane based on vertex z
-	gl_ClipDistance[0] = -a_coords.z;
-	gl_ClipDistance[1] = dot(clipData, a_coords);
+	// gl_ClipDistance[0] = -a_coords.z;
+	// gl_ClipDistance[1] = dot(clipData, a_coords);
 }
diff --git a/third_party/opengl/opengl.hpp b/third_party/opengl/opengl.hpp
index f368f573..5ead7f63 100644
--- a/third_party/opengl/opengl.hpp
+++ b/third_party/opengl/opengl.hpp
@@ -520,21 +520,21 @@ namespace OpenGL {
 	static void enableBlend() { glEnable(GL_BLEND); }
 	static void disableBlend() { glDisable(GL_BLEND); }
 	static void enableLogicOp() { glEnable(GL_COLOR_LOGIC_OP); }
-	static void disableLogicOp() { glDisable(GL_COLOR_LOGIC_OP); }
+	static void disableLogicOp() { /* glDisable(GL_COLOR_LOGIC_OP); */ }
 	static void enableDepth() { glEnable(GL_DEPTH_TEST); }
 	static void disableDepth() { glDisable(GL_DEPTH_TEST); }
 	static void enableStencil() { glEnable(GL_STENCIL_TEST); }
 	static void disableStencil() { glDisable(GL_STENCIL_TEST); }
 
-	static void enableClipPlane(GLuint index) { glEnable(GL_CLIP_DISTANCE0 + index); }
-	static void disableClipPlane(GLuint index) { glDisable(GL_CLIP_DISTANCE0 + index); }
+	static void enableClipPlane(GLuint index) { /* glEnable(GL_CLIP_DISTANCE0 + index); */ }
+	static void disableClipPlane(GLuint index) { /* glDisable(GL_CLIP_DISTANCE0 + index); */ }
 
 	static void setDepthFunc(DepthFunc func) { glDepthFunc(static_cast<GLenum>(func)); }
 	static void setColourMask(GLboolean r, GLboolean g, GLboolean b, GLboolean a) { glColorMask(r, g, b, a); }
 	static void setDepthMask(GLboolean mask) { glDepthMask(mask); }
 
 	// TODO: Add a proper enum for this
-	static void setLogicOp(GLenum op) { glLogicOp(op); }
+	static void setLogicOp(GLenum op) { /* glLogicOp(op); */ }
 
     enum Primitives {
         Triangle = GL_TRIANGLES,
